module.exports.config = {
	name: "Ø¨ÙˆÙƒÙˆ",
	version: "1.1.4",
	hasPermssion: 0,
	credits: "DungUwU",
	description: "Ø¨ÙˆÙƒÙˆ",
	commandCategory: "Ø§Ù„Ø¹Ø§Ø¨",
	usages: "[create/leave/start]\n[nai/báº§u/gÃ /tÃ´m/cua/cÃ¡]",
	dependencies: {
		"fs": "",
		"axios": ""
	},
	cooldowns: 3
};

module.exports.languages = {
	"vi": {
        "missingInput": "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† ÙØ§Ø±ØºÙ‹Ø§ Ø£Ùˆ Ø³Ø§Ù„Ø¨Ù‹Ø§",
        "wrongInput": "Ø§Ù„Ø§Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­",
        "moneyBetNotEnough": "Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø°ÙŠ ØªØ±Ø§Ù‡Ù† Ø¹Ù„ÙŠÙ‡ Ø£ÙƒØ¨Ø± Ù…Ù† Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ Ø±ØµÙŠØ¯Ùƒ!",
        "limitBet": "Ù„Ø§Ø²Ù… Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ø¹Ù„Ù‰ Ù…Ù† 50$!",
        "alreadyHave": "Ø§ÙƒÙˆ ÙƒÙŠÙ… Ø¨Ù‡Ø§ÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ !",
        "alreadyBet": "Ù„Ù‚Ø¯ Ø±Ø§Ù‡Ù†Øª Ù‡Ù†Ø§ Ù…Ù† Ù‚Ø¨Ù„.",
        "createSuccess": "[ BAUCUA ] Ø®Ù„Ù‚ Ø§Ù„Ù†Ø¬Ø§Ø­ ÙˆØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… :\nÙ„ÙˆØ¶Ø¹ Ø±Ù‡Ø§Ù† ØŒ Ø§Ø³ØªØ®Ø¯Ù… :\n%1%2 (Ø§Ù„ØºØ²Ø§Ù„","Ø§Ø¬Ø§Øµ","Ø¯Ø¬Ø§Ø¬","Ø¬Ù…Ø¨Ø±ÙŠ","Ø³Ù„Ø·Ø¹ÙˆÙ†","Ø³Ù…Ùƒ) tiá»n_cÆ°á»£c\n (ÙŠÙ…ÙƒÙ† Ø£Ù† ØªØ·Ù„Ø¨ Ø¹Ø¯Ø© Ø®ÙŠØ§Ø±Ø§Øª ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª)",
        "noGame": "[ BAUCUA ] Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ‡Ø§ Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¬Ø§Ø±ÙŠØ©!",
        "betSuccess": "ØªÙ… Ø§Ø¯Ø®Ø§Ù„ %1 Ø¯ÙˆÙ„Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­ %2",
        "notJoined": "Ù„Ù… ØªØ´Ø§Ø±Ùƒ ÙÙŠ Ø§Ù„ØªØµÙˆÙŠØª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©!",
        "outSuccess": "Ø¨Ø¹Ø¯ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­ ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø£Ù…ÙˆØ§Ù„Ùƒ!",
        "shaking": "ØªÙ‡ØªØ²...",
        "final": " => [  Ù†ØªÙŠØ¬Ø©  ] <=",
        "notAuthor": "Ø£Ù†Øª Ù„Ø³Øª ØµØ§Ø­Ø¨ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙŠÙ… ",
        "unknown": "",
        "noPlayer": "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø§Ù„ÙŠØ§ Ø£ÙŠ Ù…Ø±Ø§Ù‡Ù†ÙˆÙ†",
        "closed": "Ø£ØºÙ„Ù‚Øª Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©!"
	}
}

module.exports.onLoad = async () => {
	const fs = require("fs");
	await require('axios').get("https://raw.githubusercontent.com/RFS-ADRENO/mirai-modules/main/version.json").then(res => {
		if (res.data["baucua_x022"] != this.config.version) console.log(" ");
	})
	let path = __dirname + '/baucua/';
	if (!fs.existsSync(path)) fs.mkdirSync(path, { recursive: true });
	await require("axios").get("https://raw.githubusercontent.com/RFS-ADRENO/base64_baucua/main/data_baucua.json").then(async (res) => {
		for (let e in res.data) {
			if (fs.existsSync(path + e)) continue;
			await fs.writeFileSync(path + e, res.data[e], 'base64');
		}
	});
	if (!global.client.baucua) global.client.baucua = {};
	console.log("-----ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙˆÙƒÙˆ Ø¨Ù†Ø¬Ø§Ø­ ------");
};


module.exports.run = async function({ api, event, args, getText, Users, Currencies }) {
	if (!global.client.baucua) global.client.baucua = {};
	const { senderID, messageID, threadID } = event;
	const { increaseMoney, decreaseMoney, getData } = Currencies;
    const moneyUser = (await getData(senderID)).money;
	const sendC = (msg, callback) => api.sendMessage(msg, threadID, callback, messageID);
	const sendTC = (msg, callback) => api.sendMessage(msg, threadID, callback);
	const sendT = (msg) => sendTC(msg, () => {});
	const send = (msg) => sendC(msg, () => {});
	const threadSetting = global.data.threadData.get(parseInt(threadID)) || {};
	const prefix = (threadSetting.hasOwnProperty("PREFIX")) ? threadSetting.PREFIX : global.config.PREFIX;
	switch(args[0]) {
		case "create": {
			if (threadID in global.client.baucua) send(getText("alreadyHave"));
			else sendTC(getText("createSuccess", prefix, this.config.name), () => {
				global.client.baucua[threadID] = {
					players: 0,
					data: {},
					status: "pending",
					author: senderID
				};
			});
			return;
		};
		case "leave": {
			if (!global.client.baucua[threadID]) return send(getText("noGame"));
			if (!global.client.baucua[threadID].data[senderID]) return send(getText("notJoined"));
			else {
				global.client.baucua[threadID].players--;
				global.client.baucua[threadID].data[senderID].forEach(async (e) => {
					await increaseMoney(senderID, e.bet);
				})
				delete global.client.baucua[threadID].data[senderID];
				send(getText("outSuccess"));
			}
			return;
		};
		case "start": {
			if (!global.client.baucua[threadID]) return send(getText("noGame"));
			if (global.client.baucua[threadID].author != senderID) return send(getText("notAuthor"));
			if (global.client.baucua[threadID].players == 0) return send(getText("noPlayer"));
			sendTC(getText("shaking"), (err, info) => setTimeout(() => api.unsendMessage(info.messageID), 3000));
			await new Promise(resolve => setTimeout(resolve, 3000));
			let sixC = ["Ø§Ù„ØºØ²Ø§Ù„","Ø§Ø¬Ø§Øµ","Ø¯Ø¬Ø§Ø¬","Ø¬Ù…Ø¨Ø±ÙŠ","Ø³Ù„Ø·Ø¹ÙˆÙ†","Ø³Ù…Ùƒ"];
			let sixE = ["ðŸ¦Œ","ðŸ","ðŸ“","ðŸ¦","ðŸ¦€","ðŸŸ"];
			let _1st = Math.floor(Math.random() * 6);
			let _2nd = Math.floor(Math.random() * 6);
			let _3rd = Math.floor(Math.random() * 6);
			let ketqua = [sixC[_1st], sixC[_2nd], sixC[_3rd]];
			let name = "", win = 0, lose = 0;
			let bcatm = [];
			for (e of ketqua) {
				let imgStream = require("fs").createReadStream(__dirname + `/baucua/${e}.jpg`);
				bcatm.push(imgStream);
			}
			let msg = "";
			for (i in global.client.baucua[threadID].data) {
				name = await Users.getNameUser(i) || "Player";
				msg += `\n${name}: `;
				global.client.baucua[threadID].data[i].forEach(async (e) => {
					if (!ketqua.includes(e.name)) lose += e.bet;
					else {
						let count = 1;
						ketqua.forEach(t => {
							if (t == e.name) count++;
						})
						win += e.bet*(count-1);
						await increaseMoney(i, e.bet*count);
					}
				});
				msg += (win - lose >= 0) ? " +" : " ";
				msg += `${win - lose}$`;
				win = 0, lose = 0;
			}
			sendTC({
				body: getText("final"),
				attachment: bcatm
			}, () => sendTC(msg, () => delete global.client.baucua[threadID]));
			return;
		};
		case "end": {
			if (!global.client.baucua[threadID]) return send(getText("noGame"));
			if (global.client.baucua[threadID].author != senderID) return send(getText("notAuthor"));
			sendTC(getText("closed"), () => delete global.client.baucua[threadID]);
		}
		default: {
			if (!["Ù†Ø§ÙŠ","Ø§Ø¬Ø§Øµ","Ø¨Ø§Ùˆ","Ø¯Ø¬Ø§Ø¬","Ø¯Ø¬Ø§Ø¬","Ø¬Ù…Ø¨Ø±ÙŠ","tom","cua","cÃ¡","ca"].includes(args[0])) return send(getText("unknown", prefix, this.config.name));
			if (!global.client.baucua[threadID]) return send(getText("noGame"));
			if (args.length < 2) return send(getText("wrongInput"));
			moneyBet = parseInt(args[1]);
		    if (isNaN(moneyBet) || moneyBet <= 0) return send(getText("missingInput"));
			if (moneyBet > moneyUser) return send(getText("moneyBetNotEnough"));
			if (moneyBet < 50) return send(getText("limitBet"));
			if (threadID in global.client.baucua) {
				if (global.client.baucua[threadID].status == "pending") {
					let luachon = args[0].toLowerCase();
					if (!["nai","báº§u","bau","gÃ ","ga","tÃ´m","tom","cua","cÃ¡","ca"].includes(luachon)) return send(getText("wrongInput"));
					if (["báº§u","bau"].includes(luachon)) luachon = "báº§u";
					if (["gÃ ","ga"].includes(luachon)) luachon = "gÃ ";
					if (["tÃ´m","tom"].includes(luachon)) luachon = "tÃ´m";
					if (["cÃ¡","ca"].includes(luachon)) luachon = "cÃ¡";
					if (!global.client.baucua[threadID].data[senderID]) {
						global.client.baucua[threadID].players++;
						global.client.baucua[threadID].data[senderID] = [];
					};
					if (global.client.baucua[threadID].data[senderID] && global.client.baucua[threadID].data[senderID].find(e => e.name == luachon)) return send(getText("alreadyBet"));
					sendC(getText("betSuccess", moneyBet, luachon), () => {
						decreaseMoney(senderID, moneyBet);
						global.client.baucua[threadID].data[senderID].push({
							name: luachon,
							bet: moneyBet
						})
					});
				}
			}
			return;
		}
	}
}
